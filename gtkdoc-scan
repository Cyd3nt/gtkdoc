#!/usr/bin/perl -w
#
# gtk-doc - GTK DocBook documentation generator.
# Copyright (C) 1998  Damon Chaplin
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

#############################################################################
# Script      : gtkdoc-scan
# Description : Extracts declarations of functions, macros, enums, structs
#		and unions from header files.
#
#		It is called with a module name, an optional output directory,
#		and the header files to scan.
#
#		It outputs all declarations found to a file named
#		'$MODULE-decl.txt', and the list of decarations to another
#		file '$MODULE-decl-list.txt'.
#
#		This second list file is typically copied to
#		'$MODULE-sections.txt' and organized into sections ready to
#		output the SGML pages.
#############################################################################

use strict;
use Getopt::Long;

# Options

# name of documentation module
my $MODULE;
my $OUTPUT_DIR;

my %optctl = (module => \$MODULE,
	      'output-dir' => \$OUTPUT_DIR);
GetOptions(\%optctl, "module=s", "output-dir:s");

$OUTPUT_DIR = $OUTPUT_DIR ? $OUTPUT_DIR : ".";

if (!-d ${OUTPUT_DIR}) {
    mkdir($OUTPUT_DIR, 0755) || die "Cannot create $OUTPUT_DIR: $!";
}

# Backup existing files
if (-f "${OUTPUT_DIR}/$MODULE-decl-list.txt") {
    rename ("${OUTPUT_DIR}/$MODULE-decl-list.txt",
	    "${OUTPUT_DIR}/$MODULE-decl-list.bak");
}

if (-f "${OUTPUT_DIR}/$MODULE-decl.txt") {
    rename ("${OUTPUT_DIR}/$MODULE-decl.txt",
	    "${OUTPUT_DIR}/$MODULE-decl.bak");
}

open (DECLLIST, ">${OUTPUT_DIR}/$MODULE-decl-list.txt")
    || die "Can't open ${OUTPUT_DIR}/$MODULE-decl-list.txt";
open (DECL, ">${OUTPUT_DIR}/$MODULE-decl.txt")
    || die "Can't open ${OUTPUT_DIR}/$MODULE-decl.txt";

my $main_list = "";
my $object_list = "";
my $file;

# The header files to scan are passed in as command-line args.
for $file (@ARGV) {
    my $file_basename;
    if ($file =~ m/^.*[\/\\](.*)\.h$/) {
	$file_basename = $1;
    } else {
	print "WARNING: Can't find basename of file $file\n";
	$file_basename = $file;
    }

    # We split the output into two parts - GtkObject subclasses and everything
    # else, so that all GtkObjects/Widgets are kept together.
    my ($list, $is_object) = &ScanHeader($file);
    if ($is_object) {
	$object_list .= "<SECTION>\n<FILE>$file_basename</FILE>\n$list</SECTION>\n";
    } else {
	$main_list .= "<SECTION>\n<FILE>$file_basename</FILE>\n$list</SECTION>\n";
    }
}

print DECLLIST $object_list, $main_list;
close (DECLLIST);
close (DECL);


#############################################################################
# Function    : ScanHeader
# Description : This scans a header file, looking for declarations of
#		functions, macros, typedefs, structs and unions, which it
#		outputs to the DECL file.
# Arguments   : $input_file - the header file to scan.
# Returns     : the list of declarations found, and a boolean which
#		is 1 if the header file looks like it is describing a
#		GtkObject subclass (it looks for GTK_IS_xxx or GNOME_IS_xxx).
#############################################################################

sub ScanHeader {
    my ($input_file) = @_;
#    print "DEBUG: Scanning $input_file\n";

    my $list = "";		# Holds the resulting list of declarations.
    my ($in_comment) = 0;	# True if we are in a comment.
    my ($in_declaration) = "";	# The type of declaration we are in, e.g.
				#   'function' or 'macro'.
    my ($symbol);		# The current symbol being declared.
    my ($decl);			# Holds the declaration of the current symbol.
    my ($ret_type);		# For functions and function typedefs this
				#   holds the function's return type.
    my ($previous_line) = "";	# The previous line read in - some Gnome
				#   functions have the return type on one line
				#   and the rest of the declaration after.
    my ($first_macro) = 1;	# Used to try to skip the standard #ifdef XXX
				#   #define XXX at the start of headers.
    my ($level);		# Used to handle structs which contain nested
				#   structs or unions.
    my @objects = ();		# Holds declarations that look like GtkObject
				#   subclasses, which we remove from the list.

    if (! -f $input_file) {
	print "File doesn't exist: $input_file\n";
	return ("", 0);
    }

    open(INPUT, $input_file)
	|| die "Can't open $input_file: $!";
    while(<INPUT>) {
	# Skip to the end of the current comment.
	if ($in_comment) {
	    if (m%\*/%) {
		$in_comment = 0;
	    }
	    next;
	}

	# Look for a widget class to use as the section title.
	# GtkStyle isn't really an object.
	if (m/^struct\s+_(Gtk\S+|Gnome\S+)Class/) {
	    if ($1 ne 'GtkStyle') {
		$list .= "<TITLE>$1</TITLE>\n";
	    }
	}

	if (!$in_declaration) {
	    # Skip top-level comments.
	    if (s%^\s*/\*%%) {
		if (m%\*/%) {
#		    print "Found one-line comment: $_";
		} else {
		    $in_comment = 1;
#		    print "Found start of comment: $_";
		}
		next;
	    }

	    if (m/^\s*#\s*define\s+(\w+)/) {
		$symbol = $1;
		# We assume all macros which start with '_' are private, but
		# we accept '_' itself which is the standard gettext macro.
		# We also try to skip the first macro if it looks like the
		# standard #ifndef HEADER_FILE #define HEADER_FILE etc.
		# And we only want TRUE & FALSE defined in GLib (libdefs.h in
		# libgnome also defines them if they are not already defined).
		if (($symbol !~ m/^_/
		     && ($previous_line !~ m/#ifndef\s+$symbol/
			 || $first_macro == 0)
		     && (($symbol ne 'TRUE' && $symbol ne 'FALSE')
			 || $MODULE eq 'glib'))
		    || $symbol eq "_") {
		    $decl = $_;
		    $in_declaration = "macro";
		}
		$first_macro = 0;

	    } elsif (m/^typedef\s+((const\s+)?\w+)\s*(\**)\s*\(\*\s*(\w+)\)\s*\(/) {
		$ret_type = "$1 $3";
		$symbol = $4;
		$decl = $';
		$in_declaration = "user_function";

	    } elsif (s/^enum\s+_(\w+)\s+\{/enum $1 {/) {
		# We assume that 'enum _<enum_name> {' is really the
		# declaration of enum <enum_name>.
		$symbol = $1;
#		print "DEBUG: plain enum: $symbol\n";
		$decl = $_;
		$in_declaration = "enum";

	    } elsif (m/^typedef\s+enum\s+_(\w+)\s+\1\s*;/) {
		# We skip 'typedef <enum_name> _<enum_name>;' as the enum will
		# be declared elsewhere.
#		print "DEBUG: skipping enum typedef: $1\n";

	    } elsif (m/^typedef\s+enum/) {
		$symbol = "";
		$decl = $_;
		$in_declaration = "enum";

	    } elsif (m/^typedef\s+struct\s+_(\w+)\s+\1\s*;/) {
		# We've found a 'typedef struct _<name> <name>;'
		# This could be an opaque data structure, so we output an
		# empty declaration. If the structure is actually found that
		# will override this.
#		print "DEBUG: struct typedef: $1\n";
		&AddSymbolToList (\$list, $1);
		print DECL "<STRUCT>\n<NAME>$1</NAME>\n</STRUCT>\n";

	    } elsif (m/^typedef\s+struct\s*{/) {
		$symbol = "";
		$decl = $_;
		$level = 0;
		$in_declaration = "struct";

	    } elsif (s/^struct\s+_(\w+)/struct $1/) {
		# We assume that 'struct _<struct_name>' is really the
		# declaration of struct <struct_name>.
		$symbol = $1;
		$decl = $_;
		# We skip object structs
		if ($symbol =~ m/^(Gtk\S+|Gnome\S+)Class/
		    && $1 ne 'GtkStyle') {
#		    print "Found class: $1\n";
		    push (@objects, $1);
		} else {
		    $level = 0;
		    $in_declaration = "struct";
		}

	    } elsif (s/^union\s+_(\w+)/union $1/) {
		$symbol = $1;
		$decl = $_;
		$in_declaration = "union";

	    } elsif (m/^typedef\s+(.+[\s\*])(\w\S*);/) {
		if ($1 !~ m/^struct\s/ && $1 !~ m/^union\s/) {
#		    print "Found typedef: $_";
		    &AddSymbolToList (\$list, $2);
		    print DECL "<TYPEDEF>\n<NAME>$2</NAME>\n$_</TYPEDEF>\n";
		}
	    } elsif (m/^typedef\s+/) {
#		print "Skipping typedef: $_";

	    } elsif (m/^extern\s+/) {
#		print "Skipping extern: $_";

	    # We assume that functions which start with '_' are private, so
	    # we skip them.
	    } elsif (m/^\s*(G_INLINE_FUNC)?\s*((const\s+|unsigned\s+)*\w+)(\s\*+|\*+|\s)\s*([A-Za-z]\w*)\s*\(/) {
		$ret_type = "$2 $4";
		$symbol = $5;
		$decl = $';

#		print "Function: $symbol, Returns: $ret_type\n";
		$in_declaration = "function";

	    # Try to catch function declarations which have the return type on
	    # the previous line. But we don't want to catch complete functions
	    # which have been declared G_INLINE_FUNC, e.g. g_bit_nth_lsf in
	    # glib, or 'static inline' functions.
	    } elsif (m/^([A-Za-z]\w*)\s*\(/) {
		$symbol = $1;
		$decl = $';
		if ($previous_line !~ m/^\s*G_INLINE_FUNC/
		    && $previous_line !~ m/^\s*static\s+inline/) {
		    if ($previous_line =~ m/^((const\s*)?\w+)(\s*\*+)?/) {
			$ret_type = $1;
			if (defined ($3)) { $ret_type .= " $3"; }
#			print "Function: $symbol, Returns: $ret_type\n";
			$in_declaration = "function";
		    }
		}
	    }
	} else {
	    # If we were already in the middle of a declaration, we simply add
	    # the current line onto the end of it.
	    $decl .= $_;
	}

	# Note that sometimes functions end in ') G_GNUC_PRINTF (2, 3);'.
	if ($in_declaration eq 'function') {
	    if ($decl =~ s/\)\s*(G_GNUC_.*)?;.*$//) {
		$decl =~ s%/\*.*?\*/%%gs;	# remove comments.
#		$decl =~ s/^\s+//;		# remove leading whitespace.
#		$decl =~ s/\s+$//;		# remove trailing whitespace.
		$decl =~ s/\s*\n\s*//g;		# remove whitespace at start
						# and end of lines.
		$ret_type =~ s%/\*.*?\*/%%g;	# remove comments in ret type.
		&AddSymbolToList (\$list, $symbol);
		print DECL "<FUNCTION>\n<NAME>$symbol</NAME>\n<RETURNS>$ret_type</RETURNS>\n$decl\n</FUNCTION>\n";
		$in_declaration = "";
	    }
	}

	if ($in_declaration eq 'user_function') {
	    if ($decl =~ s/\).*$//) {
		&AddSymbolToList (\$list, $symbol);
		print DECL "<USER_FUNCTION>\n<NAME>$symbol</NAME>\n<RETURNS>$ret_type</RETURNS>\n$decl</USER_FUNCTION>\n";
		$in_declaration = "";
	    }
	}

	if ($in_declaration eq 'macro') {
	    if ($decl !~ m/\\\s*$/) {
		&AddSymbolToList (\$list, $symbol);
		print DECL "<MACRO>\n<NAME>$symbol</NAME>\n$decl</MACRO>\n";
		$in_declaration = "";
	    }
	}

	if ($in_declaration eq 'enum') {
	    if ($decl =~ m/\}\s*(\w+)?;\s*$/) {
		if ($symbol eq "") {
		    $symbol = $1;
		}
		&AddSymbolToList (\$list, $symbol);
		print DECL "<ENUM>\n<NAME>$symbol</NAME>\n$decl</ENUM>\n";
		$in_declaration = "";
	    }
	}

	# We try to handle nested stucts/unions, but unmatched brackets in
	# comments will cause problems.
	if ($in_declaration eq 'struct') {
	    if ($level <= 1 && $decl =~ m/\}\s*(\w*);\s*$/) {
		if ($symbol eq "") {
		    $symbol = $1;
		}
		&AddSymbolToList (\$list, $symbol);
		print DECL "<STRUCT>\n<NAME>$symbol</NAME>\n$decl</STRUCT>\n";
		$in_declaration = "";
	    } else {
		# We use tr to count the brackets in the line, and adjust
		# $level accordingly.
		$level += tr/{//;
		$level -= tr/}//;
	    }
	}

	if ($in_declaration eq 'union') {
	    if ($decl =~ m/\}\s*;\s*$/) {
		&AddSymbolToList (\$list, $symbol);
		print DECL "<UNION>\n<NAME>$symbol</NAME>\n$decl</UNION>\n";
		$in_declaration = "";
	    }
	}

	$previous_line = $_;
    }
    close(INPUT);

    # Take out any object structs from the list of declarations as we don't
    # want them included.
    my ($object);
    foreach $object (@objects) {
	$list =~ s/^$object\n//m;
	$list =~ s/^${object}Class\n//m;
    }


    # Try to separate the standard macros and functions, placing them at the
    # end of the current section, in a subsection named 'Standard'.
    my ($class) = "";
    my ($standard_decl) = "";
    if ($list =~ m/^GTK_IS_(.*)_CLASS/m) {
	$class = $1;
    } elsif ($list =~ m/^GTK_IS_(.*)/m) {
	$class = $1;
    } elsif ($list =~ m/^GNOME_IS_(.*)_CLASS/m) {
	$class = $1;
    } elsif ($list =~ m/^GNOME_IS_(.*)/m) {
	$class = $1;
    }

    if ($class ne "") {
#	print "Found class: $class\n";

	if ($list =~ s/^GTK_$class\n//m)            { $standard_decl .= $&; }
	if ($list =~ s/^GTK_IS_$class\n//m)         { $standard_decl .= $&; }
	if ($list =~ s/^GTK_TYPE_$class\n//m)       { $standard_decl .= $&; }
	if ($list =~ s/^gtk_.*_get_type\n//m)       { $standard_decl .= $&; }
	if ($list =~ s/^GTK_${class}_CLASS\n//m)    { $standard_decl .= $&; }
	if ($list =~ s/^GTK_IS_${class}_CLASS\n//m) { $standard_decl .= $&; }

	if ($list =~ s/^GNOME_$class\n//m)            { $standard_decl .= $&; }
	if ($list =~ s/^GNOME_IS_$class\n//m)         { $standard_decl .= $&; }
	if ($list =~ s/^GNOME_TYPE_$class\n//m)       { $standard_decl .= $&; }
	if ($list =~ s/^gnome_.*_get_type\n//m)       { $standard_decl .= $&; }
	if ($list =~ s/^GNOME_${class}_CLASS\n//m)    { $standard_decl .= $&; }
	if ($list =~ s/^GNOME_IS_${class}_CLASS\n//m) { $standard_decl .= $&; }

        if ($standard_decl ne "") {
	    $list .= "<SUBSECTION>\n<NAME>Standard</NAME>\n$standard_decl";
	}
	return ($list, 1);
    } else {
	return ($list, 0);
    }
}


#############################################################################
# Function    : AddSymbolToList
# Description : This adds the symbol to the list of declarations, but only if
#		it is not already in the list.
# Arguments   : $list - reference to the list of symbols, one on each line.
#		$symbol - the symbol to add to the list.
#############################################################################

sub AddSymbolToList {
    my ($list, $symbol) = @_;

    if ($$list =~ m/\b\Q$symbol\E\b/) {
#	print "Symbol $symbol already in list. skipping\n";
	return;
    }
    $$list .= "$symbol\n";
}
